<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hash Algorithms Explained | My Site</title><meta name=keywords content="Algorithsm"><meta name=description content="The original data is calculated into a string of fixed-length numbers through a hash function, (such as SHA-256 algorithm which is 256 bits long), the calculated value is called a hash value (or digest). Hash values are irreversible, meaning that original data cannot be deduced from the hash value. Even if the original data changes slightly, the calculated hash value will be completely different from the previous one, making it hard to break violently according to the previous value. In practical applications, it&rsquo;s often used for comparison. For instance, when we input a password, its hash value is calculated first and then transmitted to the server database. The password data stored in the database are all hash values of the original passwords, and a comparison with the hash value transmitted by the user verifies the correctness of the password."><meta name=author content><link rel=canonical href=https://oxcarbazerpine.github.io/qingtaihugo/en/posts/hash-algorithms-explained/><link crossorigin=anonymous href=../../../qingtaihugo/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as=style><link rel=icon href=https://oxcarbazerpine.github.io/qingtaihugo/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://oxcarbazerpine.github.io/qingtaihugo/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://oxcarbazerpine.github.io/qingtaihugo/favicon-32x32.png><link rel=apple-touch-icon href=https://oxcarbazerpine.github.io/qingtaihugo/apple-touch-icon.png><link rel=mask-icon href=https://oxcarbazerpine.github.io/qingtaihugo/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://oxcarbazerpine.github.io/qingtaihugo/en/posts/hash-algorithms-explained/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://oxcarbazerpine.github.io/qingtaihugo/en/posts/hash-algorithms-explained/"><meta property="og:site_name" content="My Site"><meta property="og:title" content="Hash Algorithms Explained"><meta property="og:description" content="The original data is calculated into a string of fixed-length numbers through a hash function, (such as SHA-256 algorithm which is 256 bits long), the calculated value is called a hash value (or digest). Hash values are irreversible, meaning that original data cannot be deduced from the hash value. Even if the original data changes slightly, the calculated hash value will be completely different from the previous one, making it hard to break violently according to the previous value. In practical applications, it’s often used for comparison. For instance, when we input a password, its hash value is calculated first and then transmitted to the server database. The password data stored in the database are all hash values of the original passwords, and a comparison with the hash value transmitted by the user verifies the correctness of the password."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-01T00:00:00+00:00"><meta property="article:tag" content="Algorithsm"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hash Algorithms Explained"><meta name=twitter:description content="The original data is calculated into a string of fixed-length numbers through a hash function, (such as SHA-256 algorithm which is 256 bits long), the calculated value is called a hash value (or digest). Hash values are irreversible, meaning that original data cannot be deduced from the hash value. Even if the original data changes slightly, the calculated hash value will be completely different from the previous one, making it hard to break violently according to the previous value. In practical applications, it&rsquo;s often used for comparison. For instance, when we input a password, its hash value is calculated first and then transmitted to the server database. The password data stored in the database are all hash values of the original passwords, and a comparison with the hash value transmitted by the user verifies the correctness of the password."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://oxcarbazerpine.github.io/qingtaihugo/en/posts/"},{"@type":"ListItem","position":2,"name":"Hash Algorithms Explained","item":"https://oxcarbazerpine.github.io/qingtaihugo/en/posts/hash-algorithms-explained/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hash Algorithms Explained","name":"Hash Algorithms Explained","description":"The original data is calculated into a string of fixed-length numbers through a hash function, (such as SHA-256 algorithm which is 256 bits long), the calculated value is called a hash value (or digest). Hash values are irreversible, meaning that original data cannot be deduced from the hash value. Even if the original data changes slightly, the calculated hash value will be completely different from the previous one, making it hard to break violently according to the previous value. In practical applications, it\u0026rsquo;s often used for comparison. For instance, when we input a password, its hash value is calculated first and then transmitted to the server database. The password data stored in the database are all hash values of the original passwords, and a comparison with the hash value transmitted by the user verifies the correctness of the password.\n","keywords":["Algorithsm"],"articleBody":"The original data is calculated into a string of fixed-length numbers through a hash function, (such as SHA-256 algorithm which is 256 bits long), the calculated value is called a hash value (or digest). Hash values are irreversible, meaning that original data cannot be deduced from the hash value. Even if the original data changes slightly, the calculated hash value will be completely different from the previous one, making it hard to break violently according to the previous value. In practical applications, it’s often used for comparison. For instance, when we input a password, its hash value is calculated first and then transmitted to the server database. The password data stored in the database are all hash values of the original passwords, and a comparison with the hash value transmitted by the user verifies the correctness of the password.\nWhen storing data, a hash table can be created based on the hash function, using the data itself to calculate the hash value as the index of the table. The calculation is as follows: If the data are numbers, you can use the number itself (or each digit or every certain length such as four digits as a small segment, adding up to get the sum of each part), to mod table length and get the remainder, which is the index of the data in the table. If the data is a string, you can convert it to numbers based on the ASCII table, calculate the sum, and then continue with the previous algorithm. Collision: If two pieces of data calculate the same hash value, a collision will occur, the data that arrives later can be handled in several ways: Open addressing (any data can occupy any position in the table according to the situation) 1. Linear probing - Sequentially finding empty positions 2. Plus 3 rehash - Jumping over three empty spots to find an empty position 3. Other methods\nIn closed addressing, the way of chain connection is adopted, and new data is linked to the existing data that has occupied a position.\n","wordCount":"344","inLanguage":"en","datePublished":"2024-06-01T00:00:00Z","dateModified":"2024-06-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://oxcarbazerpine.github.io/qingtaihugo/en/posts/hash-algorithms-explained/"},"publisher":{"@type":"Organization","name":"My Site","logo":{"@type":"ImageObject","url":"https://oxcarbazerpine.github.io/qingtaihugo/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://oxcarbazerpine.github.io/qingtaihugo/en/ accesskey=h title="My Site (Alt + H)">My Site</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://oxcarbazerpine.github.io/qingtaihugo/ja/ title=日本語 aria-label=日本語>Ja</a></li><li><a href=https://oxcarbazerpine.github.io/qingtaihugo/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://oxcarbazerpine.github.io/en/ title=Home><span>Home</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Hash Algorithms Explained</h1><div class=post-meta><span title='2024-06-01 00:00:00 +0000 UTC'>June 1, 2024</span></div></header><div class=post-content><p>The original data is calculated into a string of fixed-length numbers through a hash function, (such as SHA-256 algorithm which is 256 bits long), the calculated value is called a hash value (or digest). Hash values are irreversible, meaning that original data cannot be deduced from the hash value. Even if the original data changes slightly, the calculated hash value will be completely different from the previous one, making it hard to break violently according to the previous value. In practical applications, it&rsquo;s often used for comparison. For instance, when we input a password, its hash value is calculated first and then transmitted to the server database. The password data stored in the database are all hash values of the original passwords, and a comparison with the hash value transmitted by the user verifies the correctness of the password.</p><p>When storing data, a hash table can be created based on the hash function, using the data itself to calculate the hash value as the index of the table. The calculation is as follows:
If the data are numbers, you can use the number itself (or each digit or every certain length such as four digits as a small segment, adding up to get the sum of each part), to mod table length and get the remainder, which is the index of the data in the table. If the data is a string, you can convert it to numbers based on the ASCII table, calculate the sum, and then continue with the previous algorithm.
Collision:
If two pieces of data calculate the same hash value, a collision will occur, the data that arrives later can be handled in several ways:
Open addressing (any data can occupy any position in the table according to the situation)
1.
Linear probing - Sequentially finding empty positions
2.
Plus 3 rehash - Jumping over three empty spots to find an empty position
3.
Other methods</p><p>In closed addressing, the way of chain connection is adopted, and new data is linked to the existing data that has occupied a position.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://oxcarbazerpine.github.io/qingtaihugo/en/tags/algorithsm/>Algorithsm</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://oxcarbazerpine.github.io/qingtaihugo/en/>My Site</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>