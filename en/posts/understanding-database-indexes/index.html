<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding Database Indexes | My Site</title><meta name=keywords content="Database"><meta name=description content="What is an Index
A data structure that stores the index values and the disk addresses or raw data of the index entries.
Common Data Structure: B+ Tree
Why Not Other Data Structures


Binary Tree
A one-way linked list is formed for incrementing indexes.


Binary Balanced Tree (Red-Black Tree)
Each node stores the index and address. It balances the height of the left and right branches and was used by early MySQL. It is not fast enough because there are few data entries per level, and the tree is too tall."><meta name=author content><link rel=canonical href=https://oxcarbazerpine.github.io/qingtaihugo/en/posts/understanding-database-indexes/><link crossorigin=anonymous href=/qingtaihugo/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as=style><link rel=icon href=https://oxcarbazerpine.github.io/qingtaihugo/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://oxcarbazerpine.github.io/qingtaihugo/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://oxcarbazerpine.github.io/qingtaihugo/favicon-32x32.png><link rel=apple-touch-icon href=https://oxcarbazerpine.github.io/qingtaihugo/apple-touch-icon.png><link rel=mask-icon href=https://oxcarbazerpine.github.io/qingtaihugo/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://oxcarbazerpine.github.io/qingtaihugo/en/posts/understanding-database-indexes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://oxcarbazerpine.github.io/qingtaihugo/en/posts/understanding-database-indexes/"><meta property="og:site_name" content="My Site"><meta property="og:title" content="Understanding Database Indexes"><meta property="og:description" content="What is an Index A data structure that stores the index values and the disk addresses or raw data of the index entries.
Common Data Structure: B+ Tree Why Not Other Data Structures Binary Tree
A one-way linked list is formed for incrementing indexes.
Binary Balanced Tree (Red-Black Tree)
Each node stores the index and address. It balances the height of the left and right branches and was used by early MySQL. It is not fast enough because there are few data entries per level, and the tree is too tall."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-01T00:00:00+00:00"><meta property="article:tag" content="Database"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding Database Indexes"><meta name=twitter:description content="What is an Index
A data structure that stores the index values and the disk addresses or raw data of the index entries.
Common Data Structure: B+ Tree
Why Not Other Data Structures


Binary Tree
A one-way linked list is formed for incrementing indexes.


Binary Balanced Tree (Red-Black Tree)
Each node stores the index and address. It balances the height of the left and right branches and was used by early MySQL. It is not fast enough because there are few data entries per level, and the tree is too tall."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://oxcarbazerpine.github.io/qingtaihugo/en/posts/"},{"@type":"ListItem","position":2,"name":"Understanding Database Indexes","item":"https://oxcarbazerpine.github.io/qingtaihugo/en/posts/understanding-database-indexes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding Database Indexes","name":"Understanding Database Indexes","description":"What is an Index A data structure that stores the index values and the disk addresses or raw data of the index entries.\nCommon Data Structure: B+ Tree Why Not Other Data Structures Binary Tree\nA one-way linked list is formed for incrementing indexes.\nBinary Balanced Tree (Red-Black Tree)\nEach node stores the index and address. It balances the height of the left and right branches and was used by early MySQL. It is not fast enough because there are few data entries per level, and the tree is too tall.\n","keywords":["Database"],"articleBody":"What is an Index A data structure that stores the index values and the disk addresses or raw data of the index entries.\nCommon Data Structure: B+ Tree Why Not Other Data Structures Binary Tree\nA one-way linked list is formed for incrementing indexes.\nBinary Balanced Tree (Red-Black Tree)\nEach node stores the index and address. It balances the height of the left and right branches and was used by early MySQL. It is not fast enough because there are few data entries per level, and the tree is too tall.\nB Tree\nIt is multi-way. Each node stores the index and data. The index values increment from left to right without duplicate indexes.\nB+ Tree\nUsed by MySQL. All data is stored in leaf nodes. Non-leaf nodes only store redundant header indexes (like alphabetical indexes in a dictionary). Leaf nodes are linked by pointers to improve the performance of range searches.\nCharacteristics B+ Tree is a binary tree Each node has multiple data entries. In MySQL, each node is 16KB in size The tree is short because a single node stores many data entries, usually having 3 levels Storage Engines: MyISAM and InnoDB Differences MyISAM\nEach database is stored in the data directory. In each database table file, MyISAM has three types of files:\n.frm stores the table structure .MYD (D for data) stores raw data .MYI (I for index) stores table indexes, or the B+ tree structure\nIt uses non-clustered indexes where data and indexes aren’t stored together, but separately in two files. Indexes just fetch the address. InnoDB\nThe table file only has two types:\n.frm stores the table structure .idb stores data and indexes\nThe corresponding row data is all hung on the leaf nodes, saving the I/O operation of fetching data by the address. InnoDB uses clustered indexes (Clustered Index), which have better performance. Connection Internally, both use B+ Trees. After fetching the child nodes, they are loaded into memory for internal binary search.\nConsiderations Why Does InnoDB Recommend Creating a Primary Key Index and Using an Auto-Increment Integer as the Primary Key? Why have a primary key\nMySQL must first build a B+ tree to organize data, so an index is required. If it is a non-primary key index, the data stored at the leaf node is the value of the corresponding row’s primary key, then another primary key index search is carried out. If there is not even a non-primary key index, MySQL will choose a unique column from the existing columns to build an index. If there is no such column, it will create a hidden column for indexing.\nWhy use integers\nInteger comparison is fast. When using a string index, the system must look up the encoding table (ASCII or UTF-8, etc.) bit by bit and then compare them. That’s why the use of random string UUIDs isn’t recommended.\nWhy auto-increment\n(No reason provided in the original text. Add as needed.)\nIndex Types Each column’s index can be set. The default is B+ Tree, but it can be switched to Hash.\nHash MySQL has its own hash implementation. In essence, it’s an array + linked list. The hash value is calculated and used as the array key, with the data as the array value. If a hash collision occurs, the array value stores a pointer to the next node in the linked list, continuing until the end of the list points to the data. Although hash search speed can be faster than B+ Tree in general, since it cannot perform range searches, it is not widely adopted. However, for scenarios that do not require range searches, using a hash index can be considered. ","wordCount":"612","inLanguage":"en","datePublished":"2024-06-01T00:00:00Z","dateModified":"2024-06-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://oxcarbazerpine.github.io/qingtaihugo/en/posts/understanding-database-indexes/"},"publisher":{"@type":"Organization","name":"My Site","logo":{"@type":"ImageObject","url":"https://oxcarbazerpine.github.io/qingtaihugo/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://oxcarbazerpine.github.io/qingtaihugo/en/ accesskey=h title="My Site (Alt + H)">My Site</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://oxcarbazerpine.github.io/qingtaihugo/ja/ title=日本語 aria-label=日本語>Ja</a></li><li><a href=https://oxcarbazerpine.github.io/qingtaihugo/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://oxcarbazerpine.github.io/en/qingtaihugo/en/ title=Home><span>Home</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Understanding Database Indexes</h1><div class=post-meta><span title='2024-06-01 00:00:00 +0000 UTC'>June 1, 2024</span></div></header><div class=post-content><h2 id=what-is-an-index>What is an Index<a hidden class=anchor aria-hidden=true href=#what-is-an-index>#</a></h2><p>A data structure that stores the index values and the disk addresses or raw data of the index entries.</p><h2 id=common-data-structure-b-tree>Common Data Structure: B+ Tree<a hidden class=anchor aria-hidden=true href=#common-data-structure-b-tree>#</a></h2><h3 id=why-not-other-data-structures>Why Not Other Data Structures<a hidden class=anchor aria-hidden=true href=#why-not-other-data-structures>#</a></h3><ul><li><p><strong>Binary Tree</strong><br>A one-way linked list is formed for incrementing indexes.</p></li><li><p><strong>Binary Balanced Tree (Red-Black Tree)</strong><br>Each node stores the index and address. It balances the height of the left and right branches and was used by early MySQL. It is not fast enough because there are few data entries per level, and the tree is too tall.</p></li><li><p><strong>B Tree</strong><br>It is multi-way. Each node stores the index and data. The index values increment from left to right without duplicate indexes.</p></li><li><p><strong>B+ Tree</strong><br>Used by MySQL. All data is stored in leaf nodes. Non-leaf nodes only store redundant header indexes (like alphabetical indexes in a dictionary). Leaf nodes are linked by pointers to improve the performance of range searches.</p></li></ul><h3 id=characteristics>Characteristics<a hidden class=anchor aria-hidden=true href=#characteristics>#</a></h3><ul><li>B+ Tree is a binary tree</li><li>Each node has multiple data entries. In MySQL, each node is 16KB in size</li><li>The tree is short because a single node stores many data entries, usually having 3 levels</li></ul><hr><h2 id=storage-engines-myisam-and-innodb>Storage Engines: MyISAM and InnoDB<a hidden class=anchor aria-hidden=true href=#storage-engines-myisam-and-innodb>#</a></h2><h3 id=differences>Differences<a hidden class=anchor aria-hidden=true href=#differences>#</a></h3><ul><li><p><strong>MyISAM</strong><br>Each database is stored in the data directory. In each database table file, MyISAM has three types of files:</p><ul><li><code>.frm</code> stores the table structure</li><li><code>.MYD</code> (D for data) stores raw data</li><li><code>.MYI</code> (I for index) stores table indexes, or the B+ tree structure<br>It uses non-clustered indexes where data and indexes aren&rsquo;t stored together, but separately in two files. Indexes just fetch the address.</li></ul></li><li><p><strong>InnoDB</strong><br>The table file only has two types:</p><ul><li><code>.frm</code> stores the table structure</li><li><code>.idb</code> stores data and indexes<br>The corresponding row data is all hung on the leaf nodes, saving the I/O operation of fetching data by the address. InnoDB uses clustered indexes (Clustered Index), which have better performance.</li></ul></li></ul><h3 id=connection>Connection<a hidden class=anchor aria-hidden=true href=#connection>#</a></h3><p>Internally, both use B+ Trees. After fetching the child nodes, they are loaded into memory for internal binary search.</p><hr><h2 id=considerations>Considerations<a hidden class=anchor aria-hidden=true href=#considerations>#</a></h2><h3 id=why-does-innodb-recommend-creating-a-primary-key-index-and-using-an-auto-increment-integer-as-the-primary-key>Why Does InnoDB Recommend Creating a Primary Key Index and Using an Auto-Increment Integer as the Primary Key?<a hidden class=anchor aria-hidden=true href=#why-does-innodb-recommend-creating-a-primary-key-index-and-using-an-auto-increment-integer-as-the-primary-key>#</a></h3><ul><li><p><strong>Why have a primary key</strong><br>MySQL must first build a B+ tree to organize data, so an index is required. If it is a non-primary key index, the data stored at the leaf node is the value of the corresponding row&rsquo;s primary key, then another primary key index search is carried out. If there is not even a non-primary key index, MySQL will choose a unique column from the existing columns to build an index. If there is no such column, it will create a hidden column for indexing.</p></li><li><p><strong>Why use integers</strong><br>Integer comparison is fast. When using a string index, the system must look up the encoding table (ASCII or UTF-8, etc.) bit by bit and then compare them. That&rsquo;s why the use of random string UUIDs isn&rsquo;t recommended.</p></li><li><p><strong>Why auto-increment</strong><br>(No reason provided in the original text. Add as needed.)</p></li></ul><hr><h2 id=index-types>Index Types<a hidden class=anchor aria-hidden=true href=#index-types>#</a></h2><p>Each column&rsquo;s index can be set. The default is B+ Tree, but it can be switched to Hash.</p><h3 id=hash>Hash<a hidden class=anchor aria-hidden=true href=#hash>#</a></h3><ul><li>MySQL has its own hash implementation.</li><li>In essence, it&rsquo;s an array + linked list. The hash value is calculated and used as the array key, with the data as the array value. If a hash collision occurs, the array value stores a pointer to the next node in the linked list, continuing until the end of the list points to the data.</li><li>Although hash search speed can be faster than B+ Tree in general, since it cannot perform range searches, it is not widely adopted. However, for scenarios that do not require range searches, using a hash index can be considered.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://oxcarbazerpine.github.io/qingtaihugo/en/tags/database/>Database</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://oxcarbazerpine.github.io/qingtaihugo/en/>My Site</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>