---
date: 2024-06-01
draft: false
lang: ja
tags:
- Database
title: 数据库索引
---

インデックスとは？：インデックス値とインデックスエントリのディスクアドレスまたは元のデータを保存したデータ構造
一般的なデータ構造：B+ツリー
なぜ他のデータ構造を使わないのか:
二分木：逐次的なインデックスで一方向リンクリストが形成されます。
二分探索木（レッドブラックツリー）：各ノードがインデックスとアドレスを保存し、自動的に左右の枝の高さをバランス取りする特性があり、かつてはMySQLが利用していた。しかし、各レベルのデータ量は少なく、ツリーの高さが高すぎるため、探索速度が追いつかない。
Bツリー：多分岐の性質を持ち、各ノードがインデックスとデータを保存、インデックスは左から右へと増加し、重複したインデックスは存在しない。
B+ツリー：MySQLが使用しており、すべてのデータは葉ノードに存在し、非葉ノードは冗長な先頭インデックス（例えば、辞書の頭文字インデックスのような）のみを保存します。葉ノード間はポインタで接続されており、区間探索のパフォーマンスを向上させます。
特性： 
* 二分検索木型の一種 
* 各ノードには複数のデータが存在し、MySQLでは一つのノードのサイズは16KB   
* 単一ノード内に多くのデータが存在するため、ツリーの高さは低く、一般的には3層

ストレージエンジン MyISAM と InnoDB 
差分：
MyISAM：各データベースはdataディレクトリ下に保存され、各データベーステーブルファイルでは、MyISAMには.frm（テーブル構造）、.MYD（データ本体）、.MYI（インデックス）の3種類のファイルがあり、これがB+ツリー構造に対応しています。また、MyISAMは非クラスタインデックスを採用し、データとインデックスは分けて保存され、インデックスはアドレスのみを探します。
InnoDB：ライブラリのテーブルファイルには.frm（テーブル構造）と.idb（データとインデックス）の2種類のファイルのみがあり、対応する行データはすべて葉ノード上にぶら下がっており、データアクセスの際のI/O操作を1回省略できるため、クラスタインデックス（Clustered Index）を使用しながら、パフォーマンスが高いです。
接続：
内部ではB+ツリーを利用し、子ノードを取得したあとは、メモリ内で二分探索を行います。

思考：
なぜInnoDBは主キーインデックスの作成を推奨し、整数型の自増主キーを利用するのか：
* 主キーを作成する理由：MySqlのクエリロジックでは、まずB+ツリーを作成してデータを整理しなければならないため、インデックスが必須です。非主キーインデックスの場合、葉ノードが保存するデータは対応行の主キー値であり、その後、主キーインデックスの探索が再度行われます。非主キーインデックスが存在しない場合、MySQLは現在の列から一つの重複しないUnique列を選択し、インデックス探索を行います。このような列が存在しない場合、隠し列を作成し、インデックスを構築します。
* 整数型を使用する理由：操作が速く、文字列インデックスの場合、エンコーディングテーブル（ASCIIやUTF-8等）を一文字ずつ検索し、その後、前後を比較する必要があります。これは、ランダム文字列のUUIDの使用を推奨しない理由の一つです。
* 自増する理由：

各フィールドのインデックスは設定可能で、デフォルトはB+ツリーで、ハッシュを用いることも可能です。
ハッシュ：
* MySQLには独自のハッシュ実装があります
* その本質は配列＋リンクリストであり、ハッシュ値を算出し、その値を配列のキーとし、データを配列のバリューとして保存します。ハッシュ値が重複する場合（ハッシュの衝突）、配列のバリューには次のリンクリストのノードへのポインタが保存され、リンクリストの末端までデータへのポインタが続きます。
* 一般的には、探索速度はB+ツリーよりも優れていますが、区間探索ができないため、採用されていませんが、区間探索が不要な場合は、ハッシュインデックスの使用を検討することができます。